/*
THIS FILE WAS AUTOGENERATED! DO NOT EDIT!
file to edit: batch_boi.ipynb

*/



import TensorFlow
import SchwiftyNotebook_auto_diffy

public struct DataBunch<T> where T: TensorGroup {
    let trainingDataset: Dataset<T>
    let validationDataset: Dataset<T>
}

public func normalizeFeatureTensor(featureTensor: TensorFloat) -> TensorFloat {
    return TensorFloat(stacking: featureTensor.unstacked(alongAxis: 1)
                                               .map { normalizeTensor(tensor: $0) }, 
                       alongAxis: 1)
}

public struct UsedCarBatch {
    let features: TensorFloat
    let labels: TensorFloat
}

extension UsedCarBatch: TensorGroup {
    
    public static var _typeList: [TensorDataType] = [
        Float.tensorFlowDataType,
        Float.tensorFlowDataType
    ]
    public static var _unknownShapeList: [TensorShape?] = [nil, nil]
    public var _tensorHandles: [_AnyTensorHandle] {
        fatalError("unimplemented")
    }
    public func _unpackTensorHandles(into address: UnsafeMutablePointer<CTensorHandle>?) {
        address!.advanced(by: 0).initialize(to: features.handle._cTensorHandle)
        address!.advanced(by: 1).initialize(to: labels.handle._cTensorHandle)
    }
    public init(_owning tensorHandles: UnsafePointer<CTensorHandle>?) {
        features = Tensor(handle: TensorHandle(_owning: tensorHandles!.advanced(by: 0).pointee))
        labels = Tensor(handle: TensorHandle(_owning: tensorHandles!.advanced(by: 1).pointee))
    }
    public init<C: RandomAccessCollection>(_handles: C) where C.Element: _AnyTensorHandle {
        fatalError("unimplemented")
    }
}

public extension Sequence where Element == UsedCarBatch {
    var first: UsedCarBatch? {
        return first(where: { _ in true })
    }
}

public extension Dataset where Element == UsedCarBatch {
    init(featuresTensor: TensorFloat, labelsTensor: TensorFloat) {
        self.init(elements: UsedCarBatch(features: featuresTensor, 
                                     labels: labelsTensor))
    }
}

let carDataYCSV = "/home/ubuntu/.machine-learning/data/car_stuff/craigslist_labels.csv"
let carDataXCSV = "/home/ubuntu/.machine-learning/data/car_stuff/craigslist_x_data.csv"

public let numpy = Python.import("numpy")

func createDataSet(featureTensor: TensorFloat, 
                   labelTensor: TensorFloat, 
                   batchSize: Int) -> Dataset<UsedCarBatch> {
    return Dataset(featuresTensor: featureTensor, labelsTensor: labelTensor)
                    .batched(batchSize)
                    .shuffled(sampleCount: 64, 
                              randomSeed: 69, 
                              reshuffleForEachIterator: true)
}

public func fetchUsedCarDataBunch(validationSize: Double = 0.2,
                             batchSize: Int = 1028
                            ) -> DataBunch<UsedCarBatch> {
    let usedCarFeaturesArray = numpy.loadtxt(carDataXCSV, 
                                delimiter: ",", 
                                skiprows: 1, 
                                usecols: Array(1...10), 
                                dtype: Float.numpyScalarTypes.first!)
    let usedCarFeatureTensor = normalizeFeatureTensor(featureTensor: 
                                                      TensorFloat(numpy: usedCarFeaturesArray)!)
    
    let usedCarPrices = numpy.loadtxt(carDataYCSV, 
                                delimiter: ",", 
                                skiprows: 0, 
                                usecols: [1], 
                                dtype: Float.numpyScalarTypes.first!)
    let usedCarLabelsTensor = TensorFloat(numpy: usedCarPrices)!
    
    let numberOfUsedCars = usedCarFeatureTensor.shape[0]
    let numberOfUsedCarFeatures = usedCarFeatureTensor.shape[1]
    
    let validationDatasetSize = Int32(floor(validationSize * Double(numberOfUsedCars)))
    let trainingDataSetSize = Int32(numberOfUsedCars) - validationDatasetSize
    
    
    let splitFeatures = usedCarFeatureTensor
                                .split(sizes: Tensor<Int32>([validationDatasetSize, trainingDataSetSize]), 
                                       alongAxis: 0)
    let splitLabels = usedCarLabelsTensor
                            .split(sizes: Tensor<Int32>([validationDatasetSize, trainingDataSetSize]), 
                                   alongAxis: 0)
    //todo create datases
    // put in bunch
    // return bunch
    let validationDataSet = createDataSet(featureTensor: splitFeatures[0],
                                        labelTensor: splitLabels[0], batchSize: batchSize)
    let trainingDataSet = createDataSet(featureTensor: splitFeatures[1],
                                        labelTensor: splitLabels[1], batchSize: batchSize)
    return DataBunch(trainingDataset: trainingDataSet, validationDataset: validationDataSet)
}
